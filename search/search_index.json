{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#tess-asteroids","title":"tess-asteroids","text":"<p><code>tess-asteroids</code> allows you to make Target Pixel Files (TPFs) and Light Curve Files (LCFs) for any object that moves through the TESS field of view, for example solar system asteroids, comets or minor planets.</p> <p>See the full documentation, including tutorials, here. </p>"},{"location":"#installation","title":"Installation","text":"<p>The easiest way to install <code>tess-asteroids</code> and all of its dependencies is to run the following command in a terminal window:</p> <pre><code>pip install tess-asteroids\n</code></pre>"},{"location":"#lkspacecraft-dependency","title":"<code>lkspacecraft</code> dependency","text":"<p><code>tess-asteroids</code> uses <code>lkspacecraft</code> to derive barycentric time corrections (see below). The first time you run <code>lkspacecraft</code> it will download a set of files (the SPICE kernels for TESS). This will take approximately 5 minutes, depending on your internet connection, and the total file volume will be about 1GB. The files will be cached once they are downloaded and if a new version of any file becomes available they will be automatically retrieved.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>You can easily make and save a TPF and LCF for any object in the JPL Small-Body Database that has been observed by TESS. For example,</p> <pre><code>from tess_asteroids import MovingTPF\n\n# Initialise MovingTPF for asteroid 1980 VR1 in TESS sector 1\ntarget = MovingTPF.from_name(\"1980 VR1\", sector=1, camera=1, ccd=1)\n\n# Make TPF and save to file (tess-1980VR1-s0001-1-1-shape11x11-moving_tp.fits)\ntarget.make_tpf(save=True)\n\n# Make LC and save to file (tess-1980VR1-s0001-1-1-shape11x11_lc.fits)\ntarget.make_lc(save=True)\n</code></pre> <p> </p>"},{"location":"#tutorial","title":"Tutorial","text":""},{"location":"#making-a-tpf","title":"Making a TPF","text":"<p>You can create a TPF that tracks a moving object from the JPL Small-Body Database by providing the object's name and TESS sector:</p> <pre><code>from tess_asteroids import MovingTPF\n\n# Initialise MovingTPF for asteroid 1998 YT6 in TESS sector 6\ntarget = MovingTPF.from_name(\"1998 YT6\", sector=6)\n\n# Make TPF and save to file (tess-1998YT6-s0006-1-1-shape11x11-moving_tp.fits)\ntarget.make_tpf(save=True)\n</code></pre> <p>The <code>make_tpf()</code> function is retrieving and reshaping the FFI data, performing a background correction, computing an aperture and saving a SPOC-like TPF. There are a few optional parameters in the <code>make_tpf()</code> function. This includes:</p> <ul> <li><code>shape</code> controls the shape (nrows,ncols) of the TPF. Default : (11,11).</li> <li><code>bg_method</code> defines the method used to correct the background flux. Default: <code>linear_model</code>.</li> <li><code>ap_method</code> defines the method used to create the aperture. Default: <code>prf</code>.</li> <li><code>save</code> determines whether or not the TPF will be saved as a FITS file. Default: <code>False</code>.</li> <li><code>outdir</code> is the directory where the TPF will be saved. Note, the directory is not automatically created.</li> <li><code>file_name</code> is the name the TPF will be saved with. If one is not given, a default name will be generated.</li> </ul> <p>These settings can be changed as follows:</p> <pre><code># Make TPF and save to file - change default settings\ntarget.make_tpf(shape=(20,10), bg_method=\"rolling\", ap_method=\"threshold\", save=True, file_name=\"test.fits\", outdir=\"movingTPF\")\n</code></pre> <p>A TPF can only be created for a single combination of sector/camera/CCD at a time. If the object crosses multiple cameras or CCDs during a sector, then the camera/CCD must also be specified when initialising <code>MovingTPF()</code>:</p> <pre><code># Initialise MovingTPF for asteroid 2013 OS3 in TESS sector 20\ntarget = MovingTPF.from_name(\"2013 OS3\", sector=20, camera=2, ccd=3)\n</code></pre> <p>You can also initialise <code>MovingTPF()</code> with your own ephemeris:</p> <pre><code>from tess_asteroids import MovingTPF\nimport numpy as np\nimport pandas as pd\n\n# Create an artificial ephemeris\ntime = np.linspace(1790.5, 1795.5, 100)\nephem = pd.DataFrame({\n            \"time\": time,\n            \"sector\": np.full(len(time), 18),\n            \"camera\": np.full(len(time), 3),\n            \"ccd\": np.full(len(time), 2),\n            \"column\": np.linspace(500, 600, len(time)),\n            \"row\": np.linspace(1000, 900, len(time)),\n        })\n\n# Initialise MovingTPF\ntarget = MovingTPF(\"example\", ephem, barycentric=False)\n\n# Make TPF, but do not save to file\ntarget.make_tpf()\n</code></pre> <p>A few things to note about the format of the ephemeris:</p> <ul> <li><code>time</code> must have format (JD - 2457000) in the TDB scale. See explanation of the <code>barycentric</code> parameter below.</li> <li><code>sector</code>, <code>camera</code>, <code>ccd</code> must each have one unique value.</li> <li><code>column</code>, <code>row</code> must be one-indexed, where the lower left pixel of the FFI has value (1,1).</li> </ul>"},{"location":"#animating-the-tpf","title":"Animating the TPF","text":"<p><code>animate_tpf()</code> is a built-in helper function to plot the TPF and aperture over time:</p> <pre><code>from tess_asteroids import MovingTPF\n\n# Initialise MovingTPF for asteroid 1998 YT6 in TESS sector 6\ntarget = MovingTPF.from_name(\"1998 YT6\", sector=6)\n\n# Make TPF, but do not save to file\ntarget.make_tpf()\n\n# Animate TPF and save to file (tess-1998YT6-s0006-1-1-shape11x11-moving_tp.gif)\ntarget.animate_tpf(save=True)\n</code></pre>"},{"location":"#making-a-lc","title":"Making a LC","text":"<p>You can extract a LC from the TPF, using aperture photometry, as follows:</p> <pre><code>from tess_asteroids import MovingTPF\n\n# Initialise MovingTPF for asteroid 1998 YT6 in TESS sector 6\ntarget = MovingTPF.from_name(\"1998 YT6\", sector=6)\n\n# Make TPF and save to file (tess-1998YT6-s0006-1-1-shape11x11-moving_tp.fits)\ntarget.make_tpf(save=True)\n\n# Make LC and save to file (tess-1998YT6-s0006-1-1-shape11x11_lc.fits)\ntarget.make_lc(save=True)\n</code></pre> <p>The <code>make_lc()</code> function extracts the lightcurve, creates a quality mask and optionally saves the LCF. There are a few optional parameters in the <code>make_lc()</code> function. This includes:</p> <ul> <li><code>method</code> defines the method used to perform photometry. Default: <code>aperture</code>.</li> <li><code>save</code> determines whether or not the LCF will be saved as a FITS file. Default: <code>False</code>.</li> <li><code>outdir</code> is the directory where the LCF will be saved. Note, the directory is not automatically created.</li> <li><code>file_name</code> is the name the LCF will be saved with. If one is not given, a default name will be generated.</li> </ul>"},{"location":"#compatibility-with-lightkurve","title":"Compatibility with <code>lightkurve</code>","text":"<p>The TPFs and LCFs that get created by <code>tess-asteroids</code> can be opened with <code>lightkurve</code>, as follows:</p> <pre><code>import lightkurve as lk\n\n# Read in TPF and LCF, without removing bad cadences\ntpf = lk.TessTargetPixelFile(\"tess-1998YT6-s0006-1-1-shape11x11-moving_tp.fits\", quality_bitmask=\"none\")\nlc = lk.io.tess.read_tess_lightcurve(\"tess-1998YT6-s0006-1-1-shape11x11_lc.fits\", quality_bitmask=\"none\")\n\n# Plot TPF and aperture for a single frame\ntpf.plot(aperture_mask=tpf.hdu[3].data[\"APERTURE\"][200], frame=200)\n\n# Plot LC\nlc.plot()\n</code></pre>"},{"location":"#time","title":"Time","text":"<p>When you initialise <code>MovingTPF()</code>, the parameter <code>barycentric</code> is defined as follows:</p> <ul> <li><code>True</code> (default): this means the input <code>time</code> must be in TDB measured at the solar system barycenter. This is the case for the TSTART/TSTOP keywords in SPOC FFI headers and the TIME column in SPOC TPFs and LCFs.</li> <li><code>False</code>: this means the input <code>time</code> must be in TDB measured at the spacecraft. This can be recovered from the SPOC data products: for FFIs subtract the header keyword BARYCORR from TSTART/TSTOP and for TPFs/LCFs subtract the TIMECORR column from the TIME column.</li> </ul> <p>When <code>MovingTPF()</code> is initialised <code>from_name()</code>, the <code>barycentric</code> parameter is handled internally. As a user, you will only need to consider the <code>barycentric</code> parameter if you are inputting a custom ephemeris. </p> <p>For more information about time scales, see the <code>astropy</code> documentation.</p>"},{"location":"#barycentric-time-correction","title":"Barycentric time correction","text":"<p>The barycentric time correction derived by SPOC (BARYCORR) is used to transform the time at the spacecraft into the time at the solar system barycenter. This correction is calculated at the center of each FFI (i.e. one correction for each CCD) but, in reality, the correction depends upon RA and Dec. Therefore, within <code>tess-asteroids</code> we use <code>lkspacecraft</code> to re-derive the barycentric time correction based upon the position of the moving target. In the output TPFs and LCFs, you will see columns called ORIGINAL_TIME (FFI timestamp in TDB at barycenter, as derived by SPOC), ORIGINAL_TIMECORR (correction to transform time at spacecraft into time at barycenter, as derived by SPOC), TIME (re-derived time in TDB at barycenter) and TIMECORR (re-derived time correction).</p>"},{"location":"#understanding-the-tpf-and-lcf","title":"Understanding the TPF and LCF","text":"<p>The TPF has four HDUs: </p> <ul> <li>\"PRIMARY\" - a primary HDU containing only a header.</li> <li>\"PIXELS\" - a table with the same columns as a SPOC TPF. Note that \"POS_CORR1\" and \"POS_CORR2\" are defined as the offset between the center of the TPF and the expected position of the moving object given the input ephemeris. </li> <li>\"APERTURE\" - an image HDU containing the average aperture across all times.</li> <li>\"EXTRAS\" - a table HDU containing columns not found in a SPOC TPF. This includes \"RA_PRED\"/\"DEC_PRED\" (expected position of target in world coordinates), \"CORNER1\"/\"CORNER2\" (original FFI column/row of the lower-left pixel in the TPF), \"PIXEL_QUALITY\" (3D pixel quality mask identifying e.g. strap columns, non-science pixels and saturation), \"APERTURE\" (aperture as a function of time) and \"ORIGINAL_TIME\"/\"ORIGINAL_TIMECORR\" (time and barycentric correction derived by SPOC).</li> </ul> <p>The LCF has two HDUs: </p> <ul> <li>\"PRIMARY\" - a primary HDU containing only a header.</li> <li>\"LIGHTCURVE\" - a table HDU with columns including \"TIME\" (timestamps in BTJD), \"FLUX\"/\"FLUX_ERR\" (flux and error from aperture photometry) and \"TESSMAG\"/\"TESSMAG_ERR\" (measured TESS magnitude and error).</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you make use of <code>tess-asteroids</code> in your work, please cite our software using the version-specific DOI from Zenodo. You can generate a BibTex citation using Zenodo.</p>"},{"location":"movingtpf/","title":"<code>MovingTPF</code>","text":""},{"location":"movingtpf/#tess_asteroids.MovingTPF","title":"MovingTPF","text":"<pre><code>MovingTPF(\n    target: str,\n    ephem: DataFrame,\n    barycentric: bool = True,\n    metadata: dict = {},\n)\n</code></pre> <p>Create a TPF for a moving target (e.g. asteroid) from a TESS FFI. Includes methods to efficiently retrieve the data, correct the background, define an aperture mask and save a TPF in the SPOC format.</p> <p>Extract a lightcurve from the TPF, using <code>aperture</code> or <code>psf</code> photometry. Includes methods to create quality flags and save the lightcurve as a FITS file.</p> <p>Parameters:</p> <ul> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Target ID. This is only used when saving the TPF.</p> </li> <li> <code>ephem</code>               (<code>DataFrame</code>)           \u2013            <p>Target ephemeris with columns ['time', 'sector', 'camera', 'ccd', 'column', 'row']. Optional columns: ['vmag', 'hmag'].</p> <ul> <li>'time' : float in format (JD - 2457000) in TDB. See also <code>barycentric</code> below.</li> <li>'sector', 'camera', 'ccd' : int</li> <li>'column', 'row' : float. These must be one-indexed, where the lower left pixel of the FFI is (1,1).</li> <li>'vmag' : float, optional. Visual magnitude.</li> <li>'hmag' : float, optional. Absolute magnitude.</li> </ul> </li> <li> <code>barycentric</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <ul> <li>If True, the input <code>ephem['time']</code> must be in TDB measured at the solar system barycenter. This is the case for the     'TSTART'/'TSTOP' keywords in SPOC FFI headers and the 'TIME' column in SPOC TPFs and LCFs.</li> <li>If False, the input <code>ephem['time']</code> must be in TDB measured at the spacecraft. This can be recovered from the SPOC data     products: for FFIs subtract header keyword 'BARYCORR' from 'TSTART'/'TSTOP' and for TPFs/LCFs subtract the     'TIMECORR' column from the 'TIME' column.</li> </ul> </li> <li> <code>metadata</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>A dictionary with optional keys {'eccentricity': float, 'inclination': float, 'perihelion': float}.</p> <ul> <li>'eccentricity' : Target's orbital eccentricity. This is saved in the TPF/LCF headers.</li> <li>'inclination' : Target's orbital inclination, in degrees. This is saved in the TPF/LCF headers.</li> <li>'perihelion' : Target's perihelion distance, in AU. This is saved in the TPF/LCF headers.</li> </ul> </li> </ul>"},{"location":"movingtpf/#tess_asteroids.MovingTPF.from_name","title":"from_name  <code>staticmethod</code>","text":"<pre><code>from_name(\n    target: str,\n    sector: int,\n    camera: Optional[int] = None,\n    ccd: Optional[int] = None,\n    time_step: float = 0.1,\n)\n</code></pre> <p>Initialises MovingTPF from target name and TESS sector. Uses JPL/Horizons to retrieve ephemeris of target. Specifying a camera and CCD will only use the ephemeris from that camera/ccd.</p> <p>Parameters:</p> <ul> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>JPL/Horizons target ID of e.g. asteroid, comet.</p> </li> <li> <code>sector</code>               (<code>int</code>)           \u2013            <p>TESS sector number.</p> </li> <li> <code>camera</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>TESS camera. Must be defined alongside <code>ccd</code>. If <code>None</code>, full ephemeris will be used to initialise MovingTPF.</p> </li> <li> <code>ccd</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>TESS CCD. Must be defined alongside <code>camera</code>. If <code>None</code>, full ephemeris will be used to initialise MovingTPF.</p> </li> <li> <code>time_step</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>Resolution of ephemeris, in days.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MovingTPF</code>          \u2013            <p>Initialised MovingTPF with ephemeris and orbital elements from JPL/Horizons. Target ephemeris has columns ['time', 'sector', 'camera', 'ccd', 'column', 'row', 'vmag', 'hmag'].</p> <ul> <li>'time' : float with units (JD - 2457000) in TDB at spacecraft.</li> <li>'sector', 'camera', 'ccd' : int</li> <li>'column', 'row' : float. These are one-indexed, where the lower left pixel of the FFI is (1,1).</li> <li>'vmag' : float. Visual magnitude.</li> <li>'hmag' : float. Absolute magntiude.</li> </ul> </li> </ul>"},{"location":"movingtpf/#tess_asteroids.MovingTPF.make_tpf","title":"make_tpf","text":"<pre><code>make_tpf(\n    shape: Tuple[int, int] = (11, 11),\n    bg_method: str = \"linear_model\",\n    ap_method: str = \"prf\",\n    save: bool = False,\n    outdir: str = \"\",\n    file_name: Optional[str] = None,\n    **kwargs,\n)\n</code></pre> <p>Performs all steps to create and save a SPOC-like TPF for a moving target.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>Tuple(int, int)</code>, default:                   <code>(11, 11)</code> )           \u2013            <p>Defined as (nrows,ncols), in pixels. Defines the pixels that will be retrieved, centred on the target, at each timestamp.</p> </li> <li> <code>bg_method</code>               (<code>str</code>, default:                   <code>'linear_model'</code> )           \u2013            <p>Method used for background correction. One of [<code>rolling</code>, <code>linear_model</code>].</p> </li> <li> <code>ap_method</code>               (<code>str</code>, default:                   <code>'prf'</code> )           \u2013            <p>Method used to create aperture. One of [<code>threshold</code>, <code>prf</code>, <code>ellipse</code>].</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, save the TPF HDUList to a FITS file.</p> </li> <li> <code>outdir</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>If <code>save</code>, this is the directory into which the file will be saved.</p> </li> <li> <code>file_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If <code>save</code>, this is the filename that will be used. Format must be '.fits'. If no filename is given, a default one will be generated.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to <code>create_pixel_quality()</code>, <code>background_correction()</code>, <code>create_aperture()</code> and <code>to_fits()</code>.</p> </li> </ul>"},{"location":"movingtpf/#tess_asteroids.MovingTPF.make_lc","title":"make_lc","text":"<pre><code>make_lc(\n    method: str = \"aperture\",\n    save: bool = False,\n    file_name: Optional[str] = None,\n    outdir: str = \"\",\n    **kwargs,\n)\n</code></pre> <p>Performs all steps to create a lightcurve from the moving TPF, with the option to save.</p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>str</code>, default:                   <code>'aperture'</code> )           \u2013            <p>Method to extract lightcurve. One of [<code>aperture</code>, <code>psf</code>].</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, save the lightcurve HDUList to a FITS file.</p> </li> <li> <code>outdir</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>If <code>save</code>, this is the directory into which the file will be saved.</p> </li> <li> <code>file_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If <code>save</code>, this is the filename that will be used. Format must be '.fits'. If no filename is given, a default one will be generated.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to <code>to_lightcurve()</code> and <code>to_fits()</code>.</p> </li> </ul>"},{"location":"movingtpf/#tess_asteroids.MovingTPF.get_data","title":"get_data","text":"<pre><code>get_data(shape: Tuple[int, int] = (11, 11))\n</code></pre> <p>Retrieve pixel data for a moving target from a TESS FFI.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>Tuple(int, int)</code>, default:                   <code>(11, 11)</code> )           \u2013            <p>Defined as (nrows,ncols), in pixels. Defines the pixels that will be retrieved, centred on the target, at each timestamp.</p> </li> </ul>"},{"location":"movingtpf/#tess_asteroids.MovingTPF.reshape_data","title":"reshape_data","text":"<pre><code>reshape_data()\n</code></pre> <p>Reshape flux data into cube with shape (len(self.time), self.shape).</p>"},{"location":"movingtpf/#tess_asteroids.MovingTPF.background_correction","title":"background_correction","text":"<pre><code>background_correction(\n    method: str = \"linear_model\", **kwargs\n)\n</code></pre> <p>Apply background correction to reshaped flux data.</p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>str</code>, default:                   <code>'linear_model'</code> )           \u2013            <p>Method used for background correction. One of [<code>rolling</code>, <code>linear_model</code>].</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to <code>_bg_rolling_median()</code> and <code>_bg_linear_model()</code>.</p> </li> </ul>"},{"location":"movingtpf/#tess_asteroids.MovingTPF.create_aperture","title":"create_aperture","text":"<pre><code>create_aperture(method: str = 'prf', **kwargs)\n</code></pre> <p>Creates an aperture mask using method <code>threshold</code>, <code>prf</code> or <code>ellipse</code>. It creates the <code>self.aperture_mask</code> attribute with the 3D mask.</p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>str</code>, default:                   <code>'prf'</code> )           \u2013            <p>Method used for aperture estimation. One of [<code>threshold</code>, <code>prf</code>, <code>ellipse</code>].</p> </li> <li> <code>kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keywords arguments passed to aperture mask method, e.g <code>self._create_threshold_mask</code> takes <code>threshold</code> and <code>reference_pixel</code>.</p> </li> </ul>"},{"location":"movingtpf/#tess_asteroids.MovingTPF.create_pixel_quality","title":"create_pixel_quality","text":"<pre><code>create_pixel_quality(\n    sat_level: float = 100000.0,\n    sat_buffer_rad: int = 1,\n    **kwargs,\n)\n</code></pre> <p>Create a 3D pixel quality mask. The mask is a bit-wise combination of the following flags (Bit - Description):</p> <ul> <li>1 - pixel is outside of science array</li> <li>2 - pixel is in a strap column</li> <li>3 - pixel is saturated</li> <li>4 - pixel is within <code>sat_buffer_rad</code> pixels of a saturated pixel</li> <li>5 - pixel has no scattered light correction. Only relevant if <code>linear_model</code> background correction was used.</li> <li>6 - pixel had no background linear model, value was infilled. Only relevant if <code>linear_model</code> background correction was used.</li> <li>7 - pixel had negative flux value BEFORE background correction was applied.     This can happen near bleed columns from saturated stars (e.g. see Sector 6, Camera 1, CCD 4).</li> </ul> <p>Parameters:</p> <ul> <li> <code>sat_level</code>               (<code>float</code>, default:                   <code>100000.0</code> )           \u2013            <p>Flux (e-/s) above which to consider a pixel saturated.</p> </li> <li> <code>sat_buffer_rad</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Approximate radius of saturation buffer (in pixels) around each saturated pixel.</p> </li> </ul>"},{"location":"movingtpf/#tess_asteroids.MovingTPF.to_lightcurve","title":"to_lightcurve","text":"<pre><code>to_lightcurve(method: str = 'aperture', **kwargs)\n</code></pre> <p>Extract lightcurve from the moving TPF, using either <code>aperture</code> or <code>psf</code> photometry. This function creates the <code>self.lc</code> attribute, which stores the time series data.</p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>str</code>, default:                   <code>'aperture'</code> )           \u2013            <p>Method to extract lightcurve. One of <code>aperture</code> or <code>psf</code>.</p> </li> <li> <code>kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments, e.g <code>self._aperture_photometry</code> takes <code>bad_bits</code>.</p> </li> </ul>"},{"location":"movingtpf/#tess_asteroids.MovingTPF.to_fits","title":"to_fits","text":"<pre><code>to_fits(\n    file_type: str,\n    save: bool = False,\n    overwrite: bool = True,\n    outdir: str = \"\",\n    file_name: Optional[str] = None,\n    **kwargs,\n)\n</code></pre> <p>Convert the moving TPF or lightcurve data to FITS format. This function creates the <code>self.tpf_hdulist</code> or <code>self.lc_hdulist</code> attribute, which can be optionally saved to a file.</p> <p>Parameters:</p> <ul> <li> <code>file_type</code>               (<code>str</code>)           \u2013            <p>Type of file to be converted to FITS. One of [<code>tpf</code>, <code>lc</code>].</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, write the HDUList to a file.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>save</code>, this determines whether to overwrite an existing file with the same name.</p> </li> <li> <code>outdir</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>If <code>save</code>, this is the directory into which the file will be saved.</p> </li> <li> <code>file_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If <code>save</code>, this is the filename that will be used. Format must be '.fits'. If no filename is given, a default one will be generated.</p> </li> </ul>"},{"location":"movingtpf/#tess_asteroids.MovingTPF.animate_tpf","title":"animate_tpf","text":"<pre><code>animate_tpf(\n    show_aperture: bool = True,\n    show_ephemeris: bool = True,\n    step: Optional[int] = None,\n    save: bool = False,\n    outdir: str = \"\",\n    file_name: Optional[str] = None,\n    **kwargs,\n)\n</code></pre> <p>Plot animation of TPF data with optional information overlay.</p> <p>Parameters:</p> <ul> <li> <code>show_aperture</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the aperture used for photometry is displayed in the animation.</p> </li> <li> <code>show_ephemeris</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the predicted position of the target is included in the animation.</p> </li> <li> <code>step</code>               (<code>int or None</code>, default:                   <code>None</code> )           \u2013            <p>Spacing between frames, i.e. plot every nth frame.  If <code>None</code>, the spacing will be determined such that about 50 frames are shown. Showing more frames will increase the runtime and, if <code>save</code>, the file size.</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, save the animation.</p> </li> <li> <code>outdir</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>If <code>save</code>, this is the directory into which the file will be saved.</p> </li> <li> <code>file_name</code>               (<code>str or None</code>, default:                   <code>None</code> )           \u2013            <p>If <code>save</code>, this is the filename that will be used. Format must be '.gif'. If no filename is given, a default one will be generated.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Keyword arguments passed to <code>utils.animate_cube</code> such as <code>interval</code>, <code>repeat_delay</code>, <code>cnorm</code>, <code>vmin</code>, <code>vmax</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>animation</code> (              <code>html</code> )          \u2013            <p>If in a notebook environment, the animation is returned in HTML format for display purposes.</p> </li> </ul>"},{"location":"utils/","title":"<code>utils</code>","text":""},{"location":"utils/#tess_asteroids.utils","title":"utils","text":"<p>Utility functions</p>"},{"location":"utils/#tess_asteroids.utils.target_observability","title":"target_observability","text":"<pre><code>target_observability(\n    target: str,\n    sector: Optional[int] = None,\n    return_ephem: bool = False,\n)\n</code></pre> <p>Determine if a target has been observed by TESS and, if so, during which sector/camera/CCD. This function will also give an estimate of the length of time, in days, for which the target was observed on each sector/camera/CCD.</p> <p>Parameters:</p> <ul> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>JPL/Horizons target ID of e.g. asteroid, comet.</p> </li> <li> <code>sector</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>TESS sector number. If you want to know whether your target was observed during a specific sector, set this parameter. If None, all available sectors will be checked.</p> </li> <li> <code>return_ephem</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, this will return the full ephemeris of the target in addition to the observability summary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>obs</code> (              <code>DataFrame</code> )          \u2013            <p>A summary of the TESS observations of the target. There is one entry for each unique combination of sector/camera/CCD. The DataFrame has the following columns:</p> <ul> <li>'sector', 'camera', 'ccd': sector/camera/CCD target was observed in.</li> <li>'dur': approximate duration for which target was observed in this sector/camera/CCD, in days.</li> </ul> </li> <li> <code>df_ephem</code> (              <code>DataFrame</code> )          \u2013            <p>If <code>return_ephem</code> = True, the ephemeris will also be returned. This includes the pixel 'row' and 'column' of the target over time.</p> </li> </ul>"},{"location":"utils/#tess_asteroids.utils.calculate_TESSmag","title":"calculate_TESSmag","text":"<pre><code>calculate_TESSmag(\n    flux: Union[float, ndarray],\n    flux_err: Union[float, ndarray],\n    flux_fraction: Union[float, ndarray],\n)\n</code></pre> <p>Calculate TESS magnitude from a flux and a zero-point magnitude. The equation was taken from the TESS Instrument Handbook 2018 (see also Fausnaugh et al. 2021).</p> <p>This function assumes that the background flux has been perfectly removed, i.e. the only flux is that from the target. It can account for flux outside of the aperture via <code>flux_fraction</code>.</p> <p>Parameters:</p> <ul> <li> <code>flux</code>               (<code>float or ndarray</code>)           \u2013            <p>Target flux, in electrons/second.</p> </li> <li> <code>flux_err</code>               (<code>float or ndarray</code>)           \u2013            <p>Error on target flux, in electrons/second.</p> </li> <li> <code>flux_fraction</code>               (<code>float or ndarray</code>)           \u2013            <p>Fraction of target flux inside aperture. Must satisfy: 0 &lt; <code>flux_fraction</code> &lt;= 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mag</code> (              <code>float or ndarray</code> )          \u2013            <p>TESS magnitude.</p> </li> <li> <code>mag_err</code> (              <code>float or ndarray</code> )          \u2013            <p>Error on TESS magnitude.</p> </li> </ul>"},{"location":"utils/#tess_asteroids.utils.compute_moments","title":"compute_moments","text":"<pre><code>compute_moments(\n    flux: ndarray,\n    mask: Optional[ndarray] = None,\n    second_order: bool = True,\n    return_err: bool = False,\n)\n</code></pre> <p>Computes first and second order moments of a 2d distribution over time using a coordinate grid with the same shape as <code>flux</code> (nt, nrows, ncols). First order moments (X,Y) are the centroid positions. The X,Y centroids are in the range [0, ncols), [0, nrows), respectively i.e. they are zero-indexed. Second order moments (X2, Y2, XY) represent the spatial spread of the distribution.</p> <p>Parameters:</p> <ul> <li> <code>flux</code>               (<code>ndarray</code>)           \u2013            <p>3D array with flux values as (nt, nrows, ncols).</p> </li> <li> <code>mask</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>Mask to select pixels used for computing moments. Shape could be 3D (nt, nrows, ncols) or 2D (nrows, ncols). If a 2D mask is given, it is used for all frames.</p> </li> <li> <code>second_order</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, returns first and second order moments, else returns only first order moments.</p> </li> <li> <code>return_err</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, returns error on first order moments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>X, Y, XERR, YERR, X2, Y2, XY: ndarrays</code>           \u2013            <p>First (X, Y) and second (X2, Y2, XY) order moments, plus error on first order moments (XERR, YERR). If <code>second_order</code> is False, X2/Y2/XY are not returned. If <code>return_err</code> is False, XERR/YERR are not returned. Each array has shape (nt).</p> </li> </ul>"},{"location":"utils/#tess_asteroids.utils.plot_img_aperture","title":"plot_img_aperture","text":"<pre><code>plot_img_aperture(\n    img: ndarray,\n    aperture_mask: Optional[ndarray] = None,\n    cbar: bool = True,\n    ax: Optional[Axes] = None,\n    corner: Tuple[int, int] = (0, 0),\n    marker: Optional[Tuple[float, float]] = None,\n    title: str = \"\",\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    cnorm: Optional[Normalize] = None,\n)\n</code></pre> <p>Plots an image with an optional aperture mask.</p> <p>This function displays an image, optionally overlaying an aperture mask, and provides several customization options such as color scaling, title, and axis control.</p> <p>Parameters:</p> <ul> <li> <code>img</code>               (<code>2D array</code>)           \u2013            <p>The image data to be plotted, typically a 2D array or matrix representing pixel values.</p> </li> <li> <code>aperture_mask</code>               (<code>2D array</code>, default:                   <code>None</code> )           \u2013            <p>A binary mask (same shape as <code>img</code>) indicating the aperture region to be overlaid on the image.</p> </li> <li> <code>cbar</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to display a color bar alongside the plot.</p> </li> <li> <code>ax</code>               (<code>Axes</code>, default:                   <code>None</code> )           \u2013            <p>The axes object where the plot will be drawn. If not provided, a new axes will be created.</p> </li> <li> <code>corner</code>               (<code>list of two ints</code>, default:                   <code>[0, 0]</code> )           \u2013            <p>The (row, column) coordinates of the lower left corner of the image.</p> </li> <li> <code>marker</code>               (<code>tuple of float</code>, default:                   <code>None</code> )           \u2013            <p>The (row, column) coordinates at which to plot a marker in the figure. This can be used to plot the position of the moving object.</p> </li> <li> <code>title</code>               (<code>str</code>, default:                   <code>\"\"</code> )           \u2013            <p>Title of the plot. If None, no title will be shown.</p> </li> <li> <code>vmin</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Minimum value for color scale. If None, the 3%-percentile is used.</p> </li> <li> <code>vmax</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Maximum value for color scale. If None, the 97%-percentile is used.</p> </li> <li> <code>cnorm</code>               (<code>optional</code>, default:                   <code>None</code> )           \u2013            <p>Color matplotlib normalization object (e.g. astropy.visualization.simple_norm). If provided, then <code>vmax</code> and <code>vmin</code> are not used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ax</code> (              <code>Axes</code> )          \u2013            <p>The axes object containing the plot.</p> </li> </ul>"},{"location":"utils/#tess_asteroids.utils.animate_cube","title":"animate_cube","text":"<pre><code>animate_cube(\n    cube: ndarray,\n    aperture_mask: Optional[ndarray] = None,\n    corner: Union[Tuple, ndarray] = (0, 0),\n    ephemeris: Optional[ndarray] = None,\n    cadenceno: Optional[ndarray] = None,\n    time: Optional[ndarray] = None,\n    interval: int = 200,\n    repeat_delay: int = 1000,\n    step: int = 1,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    cnorm: bool = False,\n    suptitle: str = \"\",\n)\n</code></pre> <p>Creates an animated visualization of a 3D image cube, with an optional aperture mask and other customization options.</p> <p>This function animates the slices of a 3D image cube, optionally overlaying an aperture mask, and provides controls for animation speed, title, and tracking information.</p> <p>Parameters:</p> <ul> <li> <code>cube</code>               (<code>3D array</code>)           \u2013            <p>A 3D array representing the image cube (e.g., a stack of 2D images over time).</p> </li> <li> <code>aperture_mask</code>               (<code>2D or 3D array</code>, default:                   <code>None</code> )           \u2013            <p>A binary mask (same shape or a 2D slice of <code>cube</code>) to overlay on each frame of the animation. If a 2D mask is passed, it will be repeated for all times.</p> </li> <li> <code>corner</code>               (<code>list of two ints or 2D array</code>, default:                   <code>[0, 0]</code> )           \u2013            <p>The (row, column) coordinates of the lower left corner of the image.</p> </li> <li> <code>ephemeris</code>               (<code>2D array</code>, default:                   <code>None</code> )           \u2013            <p>A 2D array of object positions (row, column) to be displayed on the plot. For proper display of object position, if <code>corner</code> is [0, 0] then <code>ephemeris</code> needs to be relative to <code>corner</code>. If <code>corner</code> is provided, <code>ephemeris</code> needs to be absolute. If None, no tracking information is shown.</p> </li> <li> <code>cadenceno</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The cadence number of the frames, used for information display.</p> </li> <li> <code>time</code>               (<code>array - like</code>, default:                   <code>None</code> )           \u2013            <p>Array of time values corresponding to the slices in the cube.</p> </li> <li> <code>interval</code>               (<code>int</code>, default:                   <code>200</code> )           \u2013            <p>The time interval (in milliseconds) between each frame of the animation.</p> </li> <li> <code>repeat_delay</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>The time delay (in milliseconds) before the animation restarts once it finishes.</p> </li> <li> <code>step</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Spacing between frames, i.e. plot every nth frame.</p> </li> <li> <code>vmin</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Minimum value for color scale. If None, the 3%-percentile is used.</p> </li> <li> <code>vmax</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Maximum value for color scale. If None, the 97%-percentile is used.</p> </li> <li> <code>cnorm</code>               (<code>optional</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use asinh color normalization (from astropy.visualization.simple_norm). This can be useful for cases when the moving object is too faint compared to other features in the background. If provided, then <code>vmax</code> and <code>vmin</code> are not used.</p> </li> <li> <code>suptitle</code>               (<code>str</code>, default:                   <code>\"\"</code> )           \u2013            <p>A string to be used as the super title of the animation. It can be used to provide additional context or information about the animated data, for example the target name or observing sector/camera/ccd.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ani</code> (              <code>FuncAnimation</code> )          \u2013            <p>The animation object that can be displayed or saved.</p> </li> </ul>"},{"location":"tutorials/tutorial1_basics/","title":"Tutorial 1 - Basics","text":"In\u00a0[1]: Copied! <pre>from tess_asteroids.utils import target_observability\nfrom tess_asteroids import MovingTPF\nimport matplotlib.pyplot as plt\nimport numpy as np\n</pre> from tess_asteroids.utils import target_observability from tess_asteroids import MovingTPF import matplotlib.pyplot as plt import numpy as np In\u00a0[2]: Copied! <pre>target_observability(\"1980 VR1\")\n</pre> target_observability(\"1980 VR1\") Out[2]: sector camera ccd dur 0 1 1 2 2.0 1 1 1 1 20.0 2 68 1 2 25.0 <p>Looks like our target was observed by TESS in sectors 1 (camera 1, CCD 1 &amp; 2) and 68 (camera 1, CCD 2). Great, now we can create a TPF and LCF for that data!</p> In\u00a0[3]: Copied! <pre># Initialise MovingTPF for asteroid 1980 VR1 in TESS sector 1, camera 1, CCD 1\ntarget = MovingTPF.from_name(\"1980 VR1\", sector=1, camera=1, ccd=1)\n\n# Make TPF (if we wanted to save this as a .fits file, we would set save=True)\ntarget.make_tpf()\n</pre> # Initialise MovingTPF for asteroid 1980 VR1 in TESS sector 1, camera 1, CCD 1 target = MovingTPF.from_name(\"1980 VR1\", sector=1, camera=1, ccd=1)  # Make TPF (if we wanted to save this as a .fits file, we would set save=True) target.make_tpf() <pre>Warning from TESSSpacecraft(): {message : ErfaWarning('ERFA function \"dtf2d\" yielded 1 of \"dubious year (Note 6)\"'), category : 'ErfaWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/erfa/core.py', lineno : 133, line : None}\nWarning from prf.evaluate(): {message : LKPRFWarning('`targets` contains collateral pixels: Column(s) &gt;= 2093 '), category : 'LKPRFWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/lkprf/tessprf.py', lineno : 56, line : None}\nThe PRF model contained nans in the first frame (cadence number 274). The model was replaced with that from the following frame (cadence number 275).\nWarning from prf.evaluate(): {message : LKPRFWarning('`targets` contains collateral pixels: Column(s) &gt;= 2093 '), category : 'LKPRFWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/lkprf/tessprf.py', lineno : 56, line : None}\nThe PRF model contained nans in the first frame (cadence number 274). The model was replaced with that from the following frame (cadence number 275).\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 972/972 [00:16&lt;00:00, 60.42it/s]\nThe PRF model contained nans in the first frame (cadence number 274). The model was replaced with that from the following frame (cadence number 275).\n</pre> <p>We can visualise the TPF by using the <code>animate_tpf()</code> function:</p> In\u00a0[4]: Copied! <pre># Animate TPF (if we wanted to save this as a .gif file, we would set save=True)\ntarget.animate_tpf()\n</pre> # Animate TPF (if we wanted to save this as a .gif file, we would set save=True) target.animate_tpf() Out[4]: Once Loop Reflect In\u00a0[5]: Copied! <pre>target.tpf_hdulist[\"PRIMARY\"].header\n</pre> target.tpf_hdulist[\"PRIMARY\"].header Out[5]: <pre>SIMPLE  =                    T / conforms to FITS standard                      \nBITPIX  =                    8 / array data type                                \nNAXIS   =                    0 / number of array dimensions                     \nEXTEND  =                    T                                                  \nSIMDATA =                    F / file is based on simulated data                \nORIGIN  = 'STScI/MAST'         / institution responsible for creating this file \nSPOCDATE= '2021-05-11'         / original SPOC FFI creation date                \nSPOCVER = 'spoc-5.0.12-20200925' / SPOC version that processed FFI data         \nDATE    = '2025-07-22'         / file creation date.                            \nTSTART  =   1331.0161538379866 / observation start time in BTJD of first frame  \nTSTOP   =   1352.3909265649334 / observation start time in BTJD of last frame   \nDATE-OBS= '2018-07-31T12:22:06.508' / TSTART as UTC calendar date               \nDATE-END= '2018-08-21T21:21:46.872' / TSTOP as UTC calendar date                \nCREATOR = 'tess-asteroids'     / software used to produce this file             \nPROCVER = '1.2.6   '           / software version                               \nFILEVER = '1.0     '           / file format version                            \nTIMVERSN= 'OGIP/93-003'        / OGIP memo number for file format               \nTELESCOP= 'TESS    '           / telescope                                      \nINSTRUME= 'TESS Photometer'    / detector type                                  \nDATA_REL=                   42 / SPOC data release version number               \nOBJECT  = '1980 VR1'           / object name                                    \nTICID   =  / unique tess target identifier                                      \nSECTOR  =                    1 / Observing sector                               \nCAMERA  =                    1 / Camera number                                  \nCCD     =                    1 / CCD chip number                                \nSHAPE   = '(11,11) '           / shape of TPF (row, column)                     \nBG_CORR = 'linear_model'       / method used for background correction          \nSL_CORR = 'all_time'           / method used for scattered light correction     \nAP_TYPE = 'prf     '           / method used to create aperture                 \nAP_NPIX =                 15.0 / average number of pixels in aperture           \nPXTABLE =                    0 / pixel table id                                 \nRADESYS = 'ICRS    '           / reference frame of celestial coordinates       \nRA_OBJ  =                    0 / [deg] right ascension                          \nDEC_OBJ =                    0 / [deg] declination                              \nEQUINOX =               2000.0 / equinox of celestial coordinate system         \nPMRA    =                  0.0 / [mas/yr] RA proper motion                      \nPMDEC   =                  0.0 / [mas/yr] Dec proper motion                     \nPMTOTAL =                  0.0 / [mas/yr] total proper motion                   \nTESSMAG =                  0.0 / [mag] measured TESS magnitude                  \nTESSMAG0=                  0.0 / [mag] TESS zero-point magnitude                \nTEFF    =                  0.0 / [K] Effective temperature                      \nLOGG    =                  0.0 / [cm/s2] log10 surface gravity                  \nMH      =                  0.0 / [log10([M/H])] metallicity                     \nRADIUS  =                  0.0 / [solar radii] stellar radius                   \nTICVER  =                    0 / TICVER                                         \nVMAG    =               15.707 / [mag] predicted V magnitude                    \nHMAG    =                11.26 / [mag] H absolute magnitude                     \nPERIHEL =                2.784 / [AU] perihelion distance                       \nORBECC  =                0.032 / orbit eccentricity                             \nORBINC  =               18.115 / [deg] orbit inclination                        \nRARATE  =              -36.289 / [arcsec/h] average RA rate                     \nDECRATE =               -9.964 / [arcsec/h] average Dec rate                    \nPIXVEL  =                1.393 / [pix/h] average speed                          \nCRMITEN =                    T / spacecraft cosmic ray mitigation enabled       \nCRBLKSZ =                   10 / [exposures] s/c cosmic ray mitigation block siz\nCRSPOC  =                    F / SPOC cosmic ray cleaning enabled               </pre> <p>The \"PIXELS\" HDU contains a table with the same columns as a SPOC TPF. Note: FLUX is the background corrected flux and QUALITY corresponds to the SPOC-assigned quality flags.</p> In\u00a0[6]: Copied! <pre>target.tpf_hdulist[\"PIXELS\"].columns\n</pre> target.tpf_hdulist[\"PIXELS\"].columns Out[6]: <pre>ColDefs(\n    name = 'TIME'; format = 'D'; unit = 'BJD - 2457000, days'; disp = 'D14.7'\n    name = 'TIMECORR'; format = 'E'; unit = 'd'; disp = 'E14.7'\n    name = 'CADENCENO'; format = 'I'\n    name = 'RAW_CNTS'; format = '121I'; unit = 'ADU'; disp = 'I8'; dim = '(11, 11)'\n    name = 'FLUX'; format = '121E'; unit = 'e-/s'; disp = 'E14.7'; dim = '(11, 11)'\n    name = 'FLUX_ERR'; format = '121E'; unit = 'e-/s'; disp = 'E14.7'; dim = '(11, 11)'\n    name = 'FLUX_BKG'; format = '121E'; unit = 'e-/s'; disp = 'E14.7'; dim = '(11, 11)'\n    name = 'FLUX_BKG_ERR'; format = '121E'; unit = 'e-/s'; disp = 'E14.7'; dim = '(11, 11)'\n    name = 'QUALITY'; format = 'J'; disp = 'B16.16'\n    name = 'POS_CORR1'; format = 'E'; unit = 'pixel'; disp = 'E14.7'\n    name = 'POS_CORR2'; format = 'E'; unit = 'pixel'; disp = 'E14.7'\n)</pre> <p>The target aperture changes as a function of time. The \"APERTURE\" HDU contains the average aperture across all time. We can plot that as follows:</p> In\u00a0[7]: Copied! <pre>plt.imshow(target.tpf_hdulist[\"APERTURE\"].data, origin=\"lower\")\nplt.xlabel(\"Column\")\nplt.ylabel(\"Row\");\n</pre> plt.imshow(target.tpf_hdulist[\"APERTURE\"].data, origin=\"lower\") plt.xlabel(\"Column\") plt.ylabel(\"Row\"); <p>Finally, the \"EXTRAS\" HDU is a table containing columns not found in a SPOC TPF. For example:</p> <ul> <li>ORIGINAL_TIME is the original timestamp from the TESS FFI data. This timestamp is not accurate. TIME from the \"PIXELS\" HDU is more accurate and is the recommended value.</li> <li>CORNER1/CORNER2 are the original FFI column/row of the lower-left pixel in the TPF.</li> <li>PIXEL_QUALITY is defined by <code>tess_asteroids</code> to identify pixels that could have quality issues e.g. saturation</li> <li>APERTURE is the aperture as a function of time.</li> </ul> In\u00a0[8]: Copied! <pre>target.tpf_hdulist[\"EXTRAS\"].columns\n</pre> target.tpf_hdulist[\"EXTRAS\"].columns Out[8]: <pre>ColDefs(\n    name = 'ORIGINAL_TIME'; format = 'D'; unit = 'BJD - 2457000, days'; disp = 'D14.7'\n    name = 'ORIGINAL_TIMECORR'; format = 'E'; unit = 'd'; disp = 'E14.7'\n    name = 'RA_PRED'; format = 'E'; unit = 'deg'; disp = 'E14.7'\n    name = 'DEC_PRED'; format = 'E'; unit = 'deg'; disp = 'E14.7'\n    name = 'CORNER1'; format = 'I'; unit = 'pixel'\n    name = 'CORNER2'; format = 'I'; unit = 'pixel'\n    name = 'PIXEL_QUALITY'; format = '121I'; disp = 'B16.16'; dim = '(11, 11)'\n    name = 'APERTURE'; format = '121J'; dim = '(11, 11)'\n)</pre> In\u00a0[9]: Copied! <pre># Make LC (if we wanted to save this as a .fits file, we would set save=True)\ntarget.make_lc()\n</pre> # Make LC (if we wanted to save this as a .fits file, we would set save=True) target.make_lc() <p>Let's plot the lightcurve:</p> In\u00a0[10]: Copied! <pre>lc = target.lc[\"aperture\"]\n\nfig, ax = plt.subplots(1,1,figsize=(8,5))\nax.scatter(lc[\"time\"], lc[\"flux\"], color=\"deeppink\", marker=\".\")\nax.set_xlabel(\"Time [BJD - 2457000]\")\nax.set_ylabel(\"Flux [e-/s]\")\nax.grid(ls=\":\")\nax.set_title(f\"Asteroid {target.target} in Sector {target.sector} Camera {target.camera} CCD {target.ccd}\");\n</pre> lc = target.lc[\"aperture\"]  fig, ax = plt.subplots(1,1,figsize=(8,5)) ax.scatter(lc[\"time\"], lc[\"flux\"], color=\"deeppink\", marker=\".\") ax.set_xlabel(\"Time [BJD - 2457000]\") ax.set_ylabel(\"Flux [e-/s]\") ax.grid(ls=\":\") ax.set_title(f\"Asteroid {target.target} in Sector {target.sector} Camera {target.camera} CCD {target.ccd}\"); <p>We can use the quality flags from SPOC and <code>tess_asteroids</code> to mask cadences of lesser quality, and then we can highlight these on our lightcurve plot:</p> In\u00a0[11]: Copied! <pre># Define array of bad binary digits from SPOC (as recommended in the TESS archive manual, excluding those not included in FFI data)\nbad_spoc_bits = [1,3,5,6,15]\nspoc_value = 0\nfor bit in bad_spoc_bits:\n    spoc_value += 2**(bit-1)\n    \n# Define array of bad binary digits from tess_asteroids (any cadence with non-science or saturated pixels in aperture)\nbad_bits = [2,4]\nta_value = 0\nfor bit in bad_bits:\n    ta_value += 2**(bit-1)\n\n# Joint quality mask\nquality_mask = np.logical_and(lc[\"quality\"] &amp; ta_value == 0, target.quality &amp; spoc_value == 0)\n</pre> # Define array of bad binary digits from SPOC (as recommended in the TESS archive manual, excluding those not included in FFI data) bad_spoc_bits = [1,3,5,6,15] spoc_value = 0 for bit in bad_spoc_bits:     spoc_value += 2**(bit-1)      # Define array of bad binary digits from tess_asteroids (any cadence with non-science or saturated pixels in aperture) bad_bits = [2,4] ta_value = 0 for bit in bad_bits:     ta_value += 2**(bit-1)  # Joint quality mask quality_mask = np.logical_and(lc[\"quality\"] &amp; ta_value == 0, target.quality &amp; spoc_value == 0) In\u00a0[12]: Copied! <pre>fig, ax = plt.subplots(1,1,figsize=(8,5))\nax.scatter(lc[\"time\"][quality_mask], lc[\"flux\"][quality_mask], color=\"deeppink\", marker=\".\")\nax.scatter(lc[\"time\"][~quality_mask], lc[\"flux\"][~quality_mask], color=\"black\", marker=\"x\")\nax.set_xlabel(\"Time [BJD - 2457000]\")\nax.set_ylabel(\"Flux [e-/s]\")\nax.grid(ls=\":\")\nax.set_title(f\"Asteroid {target.target} in Sector {target.sector} Camera {target.camera} CCD {target.ccd}\");\n</pre> fig, ax = plt.subplots(1,1,figsize=(8,5)) ax.scatter(lc[\"time\"][quality_mask], lc[\"flux\"][quality_mask], color=\"deeppink\", marker=\".\") ax.scatter(lc[\"time\"][~quality_mask], lc[\"flux\"][~quality_mask], color=\"black\", marker=\"x\") ax.set_xlabel(\"Time [BJD - 2457000]\") ax.set_ylabel(\"Flux [e-/s]\") ax.grid(ls=\":\") ax.set_title(f\"Asteroid {target.target} in Sector {target.sector} Camera {target.camera} CCD {target.ccd}\"); In\u00a0[13]: Copied! <pre>target.lc_hdulist[\"PRIMARY\"].header\n</pre> target.lc_hdulist[\"PRIMARY\"].header Out[13]: <pre>SIMPLE  =                    T / conforms to FITS standard                      \nBITPIX  =                    8 / array data type                                \nNAXIS   =                    0 / number of array dimensions                     \nEXTEND  =                    T                                                  \nSIMDATA =                    F / file is based on simulated data                \nORIGIN  = 'STScI/MAST'         / institution responsible for creating this file \nSPOCDATE= '2021-05-11'         / original SPOC FFI creation date                \nSPOCVER = 'spoc-5.0.12-20200925' / SPOC version that processed FFI data         \nDATE    = '2025-07-22'         / file creation date.                            \nTSTART  =   1331.0161538379866 / observation start time in BTJD of first frame  \nTSTOP   =   1352.3909265649334 / observation start time in BTJD of last frame   \nDATE-OBS= '2018-07-31T12:22:06.508' / TSTART as UTC calendar date               \nDATE-END= '2018-08-21T21:21:46.872' / TSTOP as UTC calendar date                \nCREATOR = 'tess-asteroids'     / software used to produce this file             \nPROCVER = '1.2.6   '           / software version                               \nFILEVER = '1.0     '           / file format version                            \nTIMVERSN= 'OGIP/93-003'        / OGIP memo number for file format               \nTELESCOP= 'TESS    '           / telescope                                      \nINSTRUME= 'TESS Photometer'    / detector type                                  \nDATA_REL=                   42 / SPOC data release version number               \nOBJECT  = '1980 VR1'           / object name                                    \nTICID   =  / unique tess target identifier                                      \nSECTOR  =                    1 / Observing sector                               \nCAMERA  =                    1 / Camera number                                  \nCCD     =                    1 / CCD chip number                                \nSHAPE   = '(11,11) '           / shape of TPF (row, column)                     \nBG_CORR = 'linear_model'       / method used for background correction          \nSL_CORR = 'all_time'           / method used for scattered light correction     \nAP_TYPE = 'prf     '           / method used to create aperture                 \nAP_NPIX =                 15.0 / average number of pixels in aperture           \nBAD_BITS= '[1,3,7] '           / bits excluded during aperture photometry       \nPXTABLE =                    0 / pixel table id                                 \nRADESYS = 'ICRS    '           / reference frame of celestial coordinates       \nRA_OBJ  =                    0 / [deg] right ascension                          \nDEC_OBJ =                    0 / [deg] declination                              \nEQUINOX =               2000.0 / equinox of celestial coordinate system         \nPMRA    =                  0.0 / [mas/yr] RA proper motion                      \nPMDEC   =                  0.0 / [mas/yr] Dec proper motion                     \nPMTOTAL =                  0.0 / [mas/yr] total proper motion                   \nTESSMAG =               14.885 / [mag] measured TESS magnitude                  \nTESSMAG0=                20.44 / [mag] TESS zero-point magnitude                \nTEFF    =                  0.0 / [K] Effective temperature                      \nLOGG    =                  0.0 / [cm/s2] log10 surface gravity                  \nMH      =                  0.0 / [log10([M/H])] metallicity                     \nRADIUS  =                  0.0 / [solar radii] stellar radius                   \nTICVER  =                    0 / TICVER                                         \nVMAG    =               15.707 / [mag] predicted V magnitude                    \nHMAG    =                11.26 / [mag] H absolute magnitude                     \nPERIHEL =                2.784 / [AU] perihelion distance                       \nORBECC  =                0.032 / orbit eccentricity                             \nORBINC  =               18.115 / [deg] orbit inclination                        \nRARATE  =              -36.289 / [arcsec/h] average RA rate                     \nDECRATE =               -9.964 / [arcsec/h] average Dec rate                    \nPIXVEL  =                1.393 / [pix/h] average speed                          \nCRMITEN =                    T / spacecraft cosmic ray mitigation enabled       \nCRBLKSZ =                   10 / [exposures] s/c cosmic ray mitigation block siz\nCRSPOC  =                    F / SPOC cosmic ray cleaning enabled               </pre> <p>The \"LIGHTCURVE\" HDU contains all of the data. For example:</p> <ul> <li>FLUX and FLUX_ERR are created from the TPF using aperture photometry.</li> <li>MOM_CENTR1/2 are the measured flux-weighted centroids of the target.</li> <li>QUALITY is the original SPOC assigned quality flag.</li> <li>AP_QUALITY is defined by <code>tess_asteroids</code> to identify cadences that could have quality issues e.g. saturated pixels.</li> </ul> In\u00a0[14]: Copied! <pre>target.lc_hdulist[\"LIGHTCURVE\"].columns\n</pre> target.lc_hdulist[\"LIGHTCURVE\"].columns Out[14]: <pre>ColDefs(\n    name = 'TIME'; format = 'D'; unit = 'BJD - 2457000, days'; disp = 'D14.7'\n    name = 'TIMECORR'; format = 'E'; unit = 'd'; disp = 'E14.7'\n    name = 'ORIGINAL_TIME'; format = 'D'; unit = 'BJD - 2457000, days'; disp = 'D14.7'\n    name = 'ORIGINAL_TIMECORR'; format = 'E'; unit = 'd'; disp = 'E14.7'\n    name = 'CADENCENO'; format = 'I'\n    name = 'QUALITY'; format = 'J'; disp = 'B16.16'\n    name = 'FLUX'; format = 'E'; unit = 'e-/s'; disp = 'E14.7'\n    name = 'FLUX_ERR'; format = 'E'; unit = 'e-/s'; disp = 'E14.7'\n    name = 'TESSMAG'; format = 'E'; unit = 'mag'; disp = 'E14.7'\n    name = 'TESSMAG_ERR'; format = 'E'; unit = 'mag'; disp = 'E14.7'\n    name = 'FLUX_BKG'; format = 'E'; unit = 'e-/s'; disp = 'E14.7'\n    name = 'FLUX_BKG_ERR'; format = 'E'; unit = 'e-/s'; disp = 'E14.7'\n    name = 'MOM_CENTR1'; format = 'E'; unit = 'pixel'; disp = 'E14.7'\n    name = 'MOM_CENTR1_ERR'; format = 'E'; unit = 'pixel'; disp = 'E14.7'\n    name = 'MOM_CENTR2'; format = 'E'; unit = 'pixel'; disp = 'E14.7'\n    name = 'MOM_CENTR2_ERR'; format = 'E'; unit = 'pixel'; disp = 'E14.7'\n    name = 'RA'; format = 'E'; unit = 'deg'; disp = 'E14.7'\n    name = 'DEC'; format = 'E'; unit = 'deg'; disp = 'E14.7'\n    name = 'AP_QUALITY'; format = 'I'; disp = 'B16.16'\n    name = 'FLUX_FRACTION'; format = 'E'; disp = 'E14.7'\n    name = 'CORNER1'; format = 'I'; unit = 'pixel'\n    name = 'CORNER2'; format = 'I'; unit = 'pixel'\n    name = 'EPHEM1'; format = 'E'; unit = 'pixel'; disp = 'E14.7'\n    name = 'EPHEM2'; format = 'E'; unit = 'pixel'; disp = 'E14.7'\n    name = 'RA_PRED'; format = 'E'; unit = 'deg'; disp = 'E14.7'\n    name = 'DEC_PRED'; format = 'E'; unit = 'deg'; disp = 'E14.7'\n)</pre> <p>Let's now have a look at near-Earth asteroid 2013 OS3:</p> In\u00a0[15]: Copied! <pre>target_observability(\"2013 OS3\")\n</pre> target_observability(\"2013 OS3\") Out[15]: sector camera ccd dur 0 20 2 1 9.0 1 20 2 2 1.0 2 20 2 3 6.0 3 20 1 2 3.0 4 20 1 3 0.0 5 93 2 3 4.0 6 93 1 2 4.0 <p>This asteroid passed through five camera/CCD combinations during sector 20! That's because it moves much faster across the TESS detectors due to its proximity to Earth (and hence TESS). Notice that sector 20, camera 2, CCD 3 has duration of 0.0 days - this just means it was observed for less than a day on this CCD.</p> In\u00a0[16]: Copied! <pre># Initialise MovingTPF for asteroid 2013 OS3 in TESS sector 20, camera 2, CCD 3\ntarget = MovingTPF.from_name(\"2013 OS3\", sector=20, camera=2, ccd=3)\n\n# Make TPF\ntarget.make_tpf()\n\n# Animate TPF\ntarget.animate_tpf()\n</pre> # Initialise MovingTPF for asteroid 2013 OS3 in TESS sector 20, camera 2, CCD 3 target = MovingTPF.from_name(\"2013 OS3\", sector=20, camera=2, ccd=3)  # Make TPF target.make_tpf()  # Animate TPF target.animate_tpf() <pre>Some of the requested pixels are outside of the FFI science array (1&lt;=row&lt;=2048, 45&lt;=col&lt;=2092), but they will be set to NaN in your TPF.\nWarning from TESSSpacecraft(): {message : ErfaWarning('ERFA function \"dtf2d\" yielded 1 of \"dubious year (Note 6)\"'), category : 'ErfaWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/erfa/core.py', lineno : 133, line : None}\nWarning from prf.evaluate(): {message : LKPRFWarning('`targets` contains collateral pixels: Column(s) &gt;= 2093 '), category : 'LKPRFWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/lkprf/tessprf.py', lineno : 56, line : None}\nWarning from prf.evaluate(): {message : LKPRFWarning('`targets` contains collateral pixels: Row(s) &gt; 2048)'), category : 'LKPRFWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/lkprf/tessprf.py', lineno : 62, line : None}\nThe PRF model contained nans in the first frame (cadence number 591). The model was replaced with that from the following frame (cadence number 592).\nWarning from prf.evaluate(): {message : LKPRFWarning('`targets` contains collateral pixels: Column(s) &gt;= 2093 '), category : 'LKPRFWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/lkprf/tessprf.py', lineno : 56, line : None}\nWarning from prf.evaluate(): {message : LKPRFWarning('`targets` contains collateral pixels: Row(s) &gt; 2048)'), category : 'LKPRFWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/lkprf/tessprf.py', lineno : 62, line : None}\nThe PRF model contained nans in the first frame (cadence number 591). The model was replaced with that from the following frame (cadence number 592).\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 291/291 [00:06&lt;00:00, 47.69it/s]\nWarning from prf.evaluate(): {message : LKPRFWarning('`targets` contains collateral pixels: Row(s) &gt; 2048)'), category : 'LKPRFWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/lkprf/tessprf.py', lineno : 62, line : None}\nThe PRF model contained nans in the first frame (cadence number 591). The model was replaced with that from the following frame (cadence number 592).\n</pre> Out[16]: Once Loop Reflect <p>Notice that this asteroid has a more elongated shape. Due to the speed with which it moves across the TESS detector, the flux gets smeared along the trail during the long exposures. In a few of the frames, the asteroid reaches the edge of the TPF, so we are probably losing some of the target's flux. That's no problem, we can create a larger TPF to ensure we capture all of the flux! (Note: The first cadence of this TPF is filled with NaN values because these are non-science pixels.)</p> In\u00a0[17]: Copied! <pre># Make TPF - larger shape\ntarget.make_tpf(shape=(15,15))\n\n# Animate TPF\ntarget.animate_tpf()\n</pre> # Make TPF - larger shape target.make_tpf(shape=(15,15))  # Animate TPF target.animate_tpf() <pre>Some of the requested pixels are outside of the FFI science array (1&lt;=row&lt;=2048, 45&lt;=col&lt;=2092), but they will be set to NaN in your TPF.\nWarning from TESSSpacecraft(): {message : ErfaWarning('ERFA function \"dtf2d\" yielded 1 of \"dubious year (Note 6)\"'), category : 'ErfaWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/erfa/core.py', lineno : 133, line : None}\nWarning from prf.evaluate(): {message : LKPRFWarning('`targets` contains collateral pixels: Column(s) &gt;= 2093 '), category : 'LKPRFWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/lkprf/tessprf.py', lineno : 56, line : None}\nWarning from prf.evaluate(): {message : LKPRFWarning('`targets` contains collateral pixels: Row(s) &gt; 2048)'), category : 'LKPRFWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/lkprf/tessprf.py', lineno : 62, line : None}\nThe PRF model contained nans in the first frame (cadence number 591). The model was replaced with that from the following frame (cadence number 592).\nWarning from prf.evaluate(): {message : LKPRFWarning('`targets` contains collateral pixels: Column(s) &gt;= 2093 '), category : 'LKPRFWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/lkprf/tessprf.py', lineno : 56, line : None}\nWarning from prf.evaluate(): {message : LKPRFWarning('`targets` contains collateral pixels: Row(s) &gt; 2048)'), category : 'LKPRFWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/lkprf/tessprf.py', lineno : 62, line : None}\nThe PRF model contained nans in the first frame (cadence number 591). The model was replaced with that from the following frame (cadence number 592).\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 291/291 [00:10&lt;00:00, 28.88it/s]\nWarning from prf.evaluate(): {message : LKPRFWarning('`targets` contains collateral pixels: Row(s) &gt; 2048)'), category : 'LKPRFWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/lkprf/tessprf.py', lineno : 62, line : None}\nThe PRF model contained nans in the first frame (cadence number 591). The model was replaced with that from the following frame (cadence number 592).\n</pre> Out[17]: Once Loop Reflect <p>That looks better, the target is more comfortably within the bounds of the TPF now.</p> In\u00a0[18]: Copied! <pre># Make LC\ntarget.make_lc()\n\nlc = target.lc[\"aperture\"]\n\n# Joint quality mask\nquality_mask = np.logical_and(lc[\"quality\"] &amp; ta_value == 0, target.quality &amp; spoc_value == 0)\n\nfig, ax = plt.subplots(1,1,figsize=(8,5))\nax.scatter(lc[\"time\"][quality_mask], lc[\"flux\"][quality_mask], color=\"deeppink\", marker=\".\")\nax.scatter(lc[\"time\"][~quality_mask], lc[\"flux\"][~quality_mask], color=\"black\", marker=\"x\")\nax.set_xlabel(\"Time [BJD - 2457000]\")\nax.set_ylabel(\"Flux [e-/s]\")\nax.grid(ls=\":\")\nax.set_title(f\"Asteroid {target.target} in Sector {target.sector} Camera {target.camera} CCD {target.ccd}\");\n</pre> # Make LC target.make_lc()  lc = target.lc[\"aperture\"]  # Joint quality mask quality_mask = np.logical_and(lc[\"quality\"] &amp; ta_value == 0, target.quality &amp; spoc_value == 0)  fig, ax = plt.subplots(1,1,figsize=(8,5)) ax.scatter(lc[\"time\"][quality_mask], lc[\"flux\"][quality_mask], color=\"deeppink\", marker=\".\") ax.scatter(lc[\"time\"][~quality_mask], lc[\"flux\"][~quality_mask], color=\"black\", marker=\"x\") ax.set_xlabel(\"Time [BJD - 2457000]\") ax.set_ylabel(\"Flux [e-/s]\") ax.grid(ls=\":\") ax.set_title(f\"Asteroid {target.target} in Sector {target.sector} Camera {target.camera} CCD {target.ccd}\");"},{"location":"tutorials/tutorial1_basics/#creating-a-tpf-and-lcf","title":"Creating a TPF and LCF\u00b6","text":"<p>In this tutorial, we will learn the basics of <code>tess_asteroids</code> by creating a TPF and LCF for a couple of asteriods.</p>"},{"location":"tutorials/tutorial1_basics/#main-belt-asteroid-1980-vr1","title":"Main-belt asteroid 1980 VR1\u00b6","text":"<p>Let's start with main-belt asteroid 1980 VR1.</p>"},{"location":"tutorials/tutorial1_basics/#was-my-target-observed-by-tess","title":"Was my target observed by TESS?\u00b6","text":"<p>Firstly, we need to know if TESS observed this target and, if so, in what observing sector/camera/CCD. We can use the utils functions <code>target_observability</code> to find out. This might take a couple of minutes to run as it's checking all available TESS sectors.</p>"},{"location":"tutorials/tutorial1_basics/#creating-a-tpf","title":"Creating a TPF\u00b6","text":"<p>We can only create a TPF for one sector/camera/CCD at a time. Let's use sector 1, camera 1, CCD 1 as an example.</p> <p>Initialising <code>MovingTPF</code> with <code>from_name()</code> will query the JPL/Horizons database for the target's ephemeris during that sector. The <code>make_tpf()</code> function will then retrieve the relevant pixel data, perform a background correction and define the target aperture.</p>"},{"location":"tutorials/tutorial1_basics/#understanding-the-contents-of-the-tpf","title":"Understanding the contents of the TPF\u00b6","text":"<p>The <code>make_tpf()</code> function creates an HDUList containing all of the TPF data. If we had set <code>save=True</code>, then this would have been written to a file.</p> <p>The header of the \"PRIMARY\" HDU contains information about how the file was created, the observation and the target. Some of the keywords have been included for consistency with the SPOC TPFs (e.g. TICID, TEFF, LOGG, RADIUS...), but they are not relevant for an asteroid.</p>"},{"location":"tutorials/tutorial1_basics/#creating-a-lcf","title":"Creating a LCF\u00b6","text":"<p>After we've made our TPF, we can extract the lightcurve using aperture photometry.</p>"},{"location":"tutorials/tutorial1_basics/#understanding-the-contents-of-the-lcf","title":"Understanding the contents of the LCF\u00b6","text":"<p>The <code>make_lc()</code> function creates an HDUList containing all of the LC data. If we had set <code>save=True</code>, then this would have been written to a file.</p> <p>The header of the \"PRIMARY\" HDU contains information about how the file was created and the target. It's very similar to the primary header from the TPF:</p>"},{"location":"tutorials/tutorial1_basics/#near-earth-asteroid-2013-os3","title":"Near-Earth asteroid 2013 OS3\u00b6","text":""},{"location":"tutorials/tutorial2_rotation_periods/","title":"Tutorial 2 - Measuring rotation period","text":"<p>Once we have used <code>tess_asteroids</code> to create a lightcurve, we might want to measure the rotation period of the asteroid. This tutorial will demonstrate a simple method to do this.</p> <p>We'll use the same example main-belt asteroid that we looked at in tutorial 1. In the JPL Small Body Database, 1980 VR1 is reported to have a rotation period of 10.215 hrs. Let's see if our lightcurve agrees with that.</p> In\u00a0[1]: Copied! <pre>from tess_asteroids import MovingTPF\nimport numpy as np\nfrom astropy.timeseries import LombScargle\nfrom scipy.signal import find_peaks\nimport matplotlib.pyplot as plt\n</pre> from tess_asteroids import MovingTPF import numpy as np from astropy.timeseries import LombScargle from scipy.signal import find_peaks import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre># Initialise MovingTPF for asteroid 1980 VR1 in TESS sector 1, camera 1, CCD 1\ntarget = MovingTPF.from_name(\"1980 VR1\", sector=1, camera=1, ccd=1)\n\n# Make TPF\ntarget.make_tpf()\n\n# Make LC\ntarget.make_lc()\nlc = target.lc[\"aperture\"]\n</pre> # Initialise MovingTPF for asteroid 1980 VR1 in TESS sector 1, camera 1, CCD 1 target = MovingTPF.from_name(\"1980 VR1\", sector=1, camera=1, ccd=1)  # Make TPF target.make_tpf()  # Make LC target.make_lc() lc = target.lc[\"aperture\"] <pre>Warning from TESSSpacecraft(): {message : ErfaWarning('ERFA function \"dtf2d\" yielded 1 of \"dubious year (Note 6)\"'), category : 'ErfaWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/erfa/core.py', lineno : 133, line : None}\nWarning from prf.evaluate(): {message : LKPRFWarning('`targets` contains collateral pixels: Column(s) &gt;= 2093 '), category : 'LKPRFWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/lkprf/tessprf.py', lineno : 56, line : None}\nThe PRF model contained nans in the first frame (cadence number 274). The model was replaced with that from the following frame (cadence number 275).\nWarning from prf.evaluate(): {message : LKPRFWarning('`targets` contains collateral pixels: Column(s) &gt;= 2093 '), category : 'LKPRFWarning', filename : '/Users/atuson/miniforge3/lib/python3.10/site-packages/lkprf/tessprf.py', lineno : 56, line : None}\nThe PRF model contained nans in the first frame (cadence number 274). The model was replaced with that from the following frame (cadence number 275).\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 972/972 [00:16&lt;00:00, 58.40it/s]\nThe PRF model contained nans in the first frame (cadence number 274). The model was replaced with that from the following frame (cadence number 275).\n</pre> In\u00a0[3]: Copied! <pre># Remove nans from LC (the periodogram doesn't like nans!)\n\nno_nan = np.logical_and(~np.isnan(np.array(lc[\"flux\"])), ~np.isnan(np.array(lc[\"flux_err\"])))\ntime, flux, flux_err = lc[\"time\"][no_nan], lc[\"flux\"][no_nan], lc[\"flux_err\"][no_nan]\nprint(\"Before masking = {0}\".format(len(lc[\"time\"])))\nprint(\"After nan masking = {0}\".format(len(time)))\n</pre> # Remove nans from LC (the periodogram doesn't like nans!)  no_nan = np.logical_and(~np.isnan(np.array(lc[\"flux\"])), ~np.isnan(np.array(lc[\"flux_err\"]))) time, flux, flux_err = lc[\"time\"][no_nan], lc[\"flux\"][no_nan], lc[\"flux_err\"][no_nan] print(\"Before masking = {0}\".format(len(lc[\"time\"]))) print(\"After nan masking = {0}\".format(len(time))) <pre>Before masking = 972\nAfter nan masking = 972\n</pre> In\u00a0[4]: Copied! <pre># Remove poor quality data from LC\n\n# Define array of bad binary digits from SPOC (as recommended in the TESS archive manual, excluding those not included in FFI data)\nbad_spoc_bits = [1,3,5,6,15]\nspoc_value = 0\nfor bit in bad_spoc_bits:\n    spoc_value += 2**(bit-1)\n    \n# Define array of bad binary digits from tess_asteroids (any cadence with non-science or saturated pixels in aperture)\nbad_bits = [2,4]\nta_value = 0\nfor bit in bad_bits:\n    ta_value += 2**(bit-1)\n\n# Joint quality mask\nquality_mask = np.logical_and(lc[\"quality\"] &amp; ta_value == 0, target.quality &amp; spoc_value == 0)\n\ngood_quality = np.logical_and(lc[\"quality\"][no_nan] &amp; ta_value == 0, target.quality[no_nan] &amp; spoc_value == 0)\ntime, flux, flux_err = time[good_quality], flux[good_quality], flux_err[good_quality]\nprint(\"After bad data masking = {0}\".format(len(time)))\n</pre> # Remove poor quality data from LC  # Define array of bad binary digits from SPOC (as recommended in the TESS archive manual, excluding those not included in FFI data) bad_spoc_bits = [1,3,5,6,15] spoc_value = 0 for bit in bad_spoc_bits:     spoc_value += 2**(bit-1)      # Define array of bad binary digits from tess_asteroids (any cadence with non-science or saturated pixels in aperture) bad_bits = [2,4] ta_value = 0 for bit in bad_bits:     ta_value += 2**(bit-1)  # Joint quality mask quality_mask = np.logical_and(lc[\"quality\"] &amp; ta_value == 0, target.quality &amp; spoc_value == 0)  good_quality = np.logical_and(lc[\"quality\"][no_nan] &amp; ta_value == 0, target.quality[no_nan] &amp; spoc_value == 0) time, flux, flux_err = time[good_quality], flux[good_quality], flux_err[good_quality] print(\"After bad data masking = {0}\".format(len(time))) <pre>After bad data masking = 959\n</pre> In\u00a0[5]: Copied! <pre># Min/max period, in days, and frequency\ncadence = 30/60/24   # sector 1 had 30min observing cadence\nPmin, Pmax = cadence*2, (np.nanmax(time)-np.nanmin(time))\nfmin, fmax = 1/Pmax, 1/Pmin\n\n# Define period and frequency grid\nfrequency_grid = np.linspace(fmin, fmax, 10000)\nperiod_grid = 1.0/frequency_grid\n\n# Run periodogram\nls = LombScargle(time, flux, flux_err)\npower = ls.power(frequency_grid)\n\n# False alarm levels\nprobabilities = [0.1,0.05,0.01]\nfalse_alarm_levels = ls.false_alarm_level(probabilities)\n\n# Find peaks in the periodogram above 1% FAP.\nlevel = false_alarm_levels[2]\npeaks, peak_properties = find_peaks(power, height=level)\npeak_periods = period_grid[peaks]\nsorted_ind = np.argsort(peak_properties[\"peak_heights\"])[::-1]\nbest_period = peak_periods[sorted_ind[0]]*24\n</pre> # Min/max period, in days, and frequency cadence = 30/60/24   # sector 1 had 30min observing cadence Pmin, Pmax = cadence*2, (np.nanmax(time)-np.nanmin(time)) fmin, fmax = 1/Pmax, 1/Pmin  # Define period and frequency grid frequency_grid = np.linspace(fmin, fmax, 10000) period_grid = 1.0/frequency_grid  # Run periodogram ls = LombScargle(time, flux, flux_err) power = ls.power(frequency_grid)  # False alarm levels probabilities = [0.1,0.05,0.01] false_alarm_levels = ls.false_alarm_level(probabilities)  # Find peaks in the periodogram above 1% FAP. level = false_alarm_levels[2] peaks, peak_properties = find_peaks(power, height=level) peak_periods = period_grid[peaks] sorted_ind = np.argsort(peak_properties[\"peak_heights\"])[::-1] best_period = peak_periods[sorted_ind[0]]*24 In\u00a0[6]: Copied! <pre># Plot the LC and periodogram\nfig, (ax1,ax2) = plt.subplots(1,2, figsize=(10,5), width_ratios=[2,1])\n\nax1.scatter(time, flux, color='deeppink', marker='.')\nax1.set_xlabel(\"Time [BJD - 2457000]\")\nax1.set_ylabel(\"Flux [e-/s]\")\nax1.grid(ls=\":\")\n\nax2.plot(period_grid*24, power, 'k', lw=0.8, zorder=0)\nax2.axhline(y=level, color='r', lw=0.8, label = \"1% false alarm level\")\nax2.axvline(x=best_period, ls=':', color='deeppink', zorder=2, label = \"Measured period\")\nax2.set_xlabel(\"Period [hrs]\")\nax2.set_ylabel(\"Power\")\nax2.legend(loc=\"upper right\")\nax2.grid(ls=\":\")\n\nfig.suptitle(\"Asteroid {0}: Sector {1}, Camera {2}, CCD {3}\\nMeasured period = {4:.03f} hrs\".format(target.target, target.sector,target.camera,target.ccd,best_period));\n</pre> # Plot the LC and periodogram fig, (ax1,ax2) = plt.subplots(1,2, figsize=(10,5), width_ratios=[2,1])  ax1.scatter(time, flux, color='deeppink', marker='.') ax1.set_xlabel(\"Time [BJD - 2457000]\") ax1.set_ylabel(\"Flux [e-/s]\") ax1.grid(ls=\":\")  ax2.plot(period_grid*24, power, 'k', lw=0.8, zorder=0) ax2.axhline(y=level, color='r', lw=0.8, label = \"1% false alarm level\") ax2.axvline(x=best_period, ls=':', color='deeppink', zorder=2, label = \"Measured period\") ax2.set_xlabel(\"Period [hrs]\") ax2.set_ylabel(\"Power\") ax2.legend(loc=\"upper right\") ax2.grid(ls=\":\")  fig.suptitle(\"Asteroid {0}: Sector {1}, Camera {2}, CCD {3}\\nMeasured period = {4:.03f} hrs\".format(target.target, target.sector,target.camera,target.ccd,best_period)); <p>Yay, our results show good agreement with the expected rotation period!</p>"},{"location":"tutorials/tutorial2_rotation_periods/#measuring-rotation-period-from-the-lightcurve","title":"Measuring rotation period from the lightcurve\u00b6","text":""},{"location":"tutorials/tutorial2_rotation_periods/#create-the-lightcurve","title":"Create the lightcurve\u00b6","text":""},{"location":"tutorials/tutorial2_rotation_periods/#clean-the-data","title":"Clean the data\u00b6","text":""},{"location":"tutorials/tutorial2_rotation_periods/#run-a-periodogram","title":"Run a periodogram\u00b6","text":""},{"location":"tutorials/tutorial2_rotation_periods/#plot-the-result","title":"Plot the result\u00b6","text":""}]}